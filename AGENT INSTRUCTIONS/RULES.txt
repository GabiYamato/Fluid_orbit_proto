================================================================================
                       FLUID ORBIT - AGENT GROUND RULES
================================================================================

These are the absolute rules that must be followed when working on this project.
Violating these rules may cause breaking changes, security issues, or poor UX.

================================================================================
                            GENERAL RULES
================================================================================

1. NEVER HARDCODE SECRETS
   - API keys, passwords, and secrets go in .env ONLY
   - Use os.environ.get() or config.py for access
   - Never commit .env to version control

2. ALWAYS USE ABSOLUTE IMPORTS
   - Backend: from app.services.rag_service import RAGService
   - Frontend: import { Component } from '@/app/components/Component'

3. PRESERVE EXISTING FUNCTIONALITY
   - Before modifying a file, understand its current behavior
   - Run tests or verify functionality before and after changes
   - Don't remove features without explicit user request

4. FOLLOW THE ESTABLISHED PATTERNS
   - Backend: FastAPI routers → services → models
   - Frontend: App Router structure with components directory
   - Use existing service instances (don't create duplicates)

================================================================================
                            BACKEND RULES
================================================================================

5. MAINTAIN THE RAG PIPELINE ORDER
   The 3-level escalation strategy MUST be preserved:
   - Level 1: Vector DB (Qdrant) - always try first
   - Level 2: Retailer scraping - if Level 1 < 3 results
   - Level 3: Deep web crawling - fallback only
   
6. ALWAYS INDEX SCRAPED PRODUCTS
   Every product discovered MUST be indexed back to Qdrant.
   This is the feedback loop that makes the system smarter.

7. USE LOCAL EMBEDDINGS BY DEFAULT
   - Default: all-MiniLM-L6-v2 (no API key needed)
   - Only use OpenAI/Gemini embeddings if explicitly configured
   - Embedding model consistency is CRITICAL for search

8. HANDLE ERRORS GRACEFULLY
   - Never let the API crash
   - Always return structured error responses
   - Log errors with full context (use the logger)

9. RESPECT RATE LIMITS
   - Scraping: Max 10 concurrent retailers
   - API calls: Use Redis rate limiting
   - Never overwhelm external services

10. KEEP DATABASE MIGRATIONS SAFE
    - Never drop tables in production
    - Always backup before schema changes
    - Use SQLAlchemy migrations properly

================================================================================
                            FRONTEND RULES
================================================================================

11. MAINTAIN RESPONSIVE DESIGN
    - All components must work on mobile (320px+)
    - Use Tailwind breakpoints: sm, md, lg, xl, 2xl
    - Test on multiple screen sizes

12. PRESERVE THE NEOBRUTALISM AESTHETIC
    - Thick black borders (border-2 border-black)
    - Hard drop shadows (shadow-[4px_4px_0px_0px_rgba(0,0,0,1)])
    - Bold typography
    - Pink accent: #E31B5B

13. USE THE EXISTING COMPONENT LIBRARY
    - Check /app/components before creating new ones
    - Extend existing components rather than duplicating
    - Keep component files under 500 lines when possible

14. HANDLE LOADING & ERROR STATES
    - Always show loading indicators during API calls
    - Display user-friendly error messages
    - Never leave the UI in a broken state

15. MAINTAIN TYPE SAFETY
    - All TypeScript: strict mode enabled
    - Define interfaces for all API responses
    - Avoid 'any' type unless absolutely necessary

================================================================================
                            SERVICE RULES
================================================================================

16. RAG SERVICE IS THE ORCHESTRATOR
    - All product searches go through RAGService
    - Don't bypass it with direct scraping calls
    - Maintains consistency and indexing

17. INTENT PARSER DETERMINES CLARIFICATIONS
    - Fashion queries should get smart clarifications
    - Don't duplicate clarification logic elsewhere
    - Single-prompt clarification (no re-asking)

18. SCRAPING SERVICE HANDLES ALL RETAILERS
    - Add new retailers to scraping_service.py
    - Follow the existing retailer config pattern
    - Test new retailers before merging

19. USE EXISTING SERVICE INSTANCES
    - rag_service (singleton in services/__init__.py)
    - intent_parser_service (global instance)
    - embedding_service (LocalEmbeddingService)

================================================================================
                            API RULES
================================================================================

20. FOLLOW REST CONVENTIONS
    - GET for retrieval
    - POST for creation
    - PUT for updates
    - DELETE for removal

21. MAINTAIN AUTHENTICATION
    - Protected routes require JWT token
    - Use get_current_user dependency
    - Never expose user data without auth

22. STRUCTURED RESPONSES
    - Success: { "status": "success", "data": {...} }
    - Error: { "status": "error", "message": "..." }
    - Always include appropriate HTTP status codes

================================================================================
                            DATA RULES
================================================================================

23. PRODUCT DATA INTEGRITY
    - Price must be > $0.00 (scraped, never LLM-generated)
    - URL must be valid product link
    - Never show placeholder images if real ones exist

24. EMBEDDING CONSISTENCY
    - All embeddings must use the same model
    - Re-embed collection if model changes
    - Dimension mismatch = broken search

25. CHAT HISTORY PERSISTENCE
    - Sessions survive server restarts
    - Limit history to prevent bloat
    - User can only see their own history

================================================================================
                            TESTING RULES
================================================================================

26. TEST BEFORE SHIPPING
    - Run the frontend dev server (npm run dev)
    - Run the backend server (uvicorn main:app --reload)
    - Verify the feature works end-to-end

27. CHECK SCRAPING RELIABILITY
    - Not all retailers work 100% of the time
    - Anti-bot measures may block requests
    - Graceful degradation is essential

28. VERIFY PRODUCT LINKS
    - All product cards must link to real products
    - Test the redirect before closing the task

================================================================================
                            PERFORMANCE RULES
================================================================================

29. OPTIMIZE FOR SPEED
    - Vector DB queries < 200ms
    - Scraping uses parallel batching
    - Cache frequently accessed data

30. MINIMIZE LLM CALLS
    - Use keyword filtering before LLM filtering
    - Cache LLM responses when possible
    - Consider response streaming for perceived speed

================================================================================
                            DOCUMENTATION RULES
================================================================================

31. DOCUMENT MAJOR CHANGES
    - Update README.md for new features
    - Add comments to complex logic
    - Keep instructions.txt current

32. LOG IMPORTANT ACTIONS
    - Use structured logging
    - Include relevant context (user_id, query, etc.)
    - Log file: ./logs/shopgpt_YYYYMMDD.log

================================================================================
                            SECURITY RULES
================================================================================

33. VALIDATE ALL INPUT
    - Sanitize user queries
    - Validate file paths
    - Check authorization on every request

34. SECURE AUTHENTICATION
    - Hash passwords with bcrypt
    - JWT tokens with expiration
    - Secure Google OAuth flow

35. PROTECT USER DATA
    - Users can only access their own data
    - No cross-user data leakage
    - Implement proper session isolation

================================================================================
                               PRIORITIES
================================================================================

When conflicts arise, prioritize in this order:

1. SECURITY - Never compromise user safety
2. DATA INTEGRITY - Accurate product data
3. USER EXPERIENCE - Smooth, responsive UI
4. PERFORMANCE - Fast responses
5. CODE QUALITY - Clean, maintainable code

================================================================================
                            END OF RULES
================================================================================
